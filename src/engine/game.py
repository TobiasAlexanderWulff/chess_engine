from __future__ import annotations

from dataclasses import dataclass, field
from typing import Dict, List

from .board import Board
from .move import Move


@dataclass
class Game:
    """Game wrapper around a board with helper operations.

    Attributes:
        board (Board): Current board instance.
        move_stack (List[Move]): Played moves in order for undo support.
        repetition (Dict[int, int]): Counts of encountered Zobrist hashes for
            repetition detection.
    """

    board: Board
    move_stack: List[Move] = field(default_factory=list)
    repetition: Dict[int, int] = field(default_factory=dict)

    @classmethod
    def new(cls) -> "Game":
        """Create a new game starting from the standard chess initial position.

        Returns:
            Game: Game object containing a board initialized to the starting
            position.
        """
        return cls(board=Board.startpos())

    @classmethod
    def from_fen(cls, fen: str) -> "Game":
        """Create a game with its board loaded from a FEN string.

        Args:
            fen (str): FEN string describing the position to load.

        Returns:
            Game: Game instance containing a board loaded from ``fen``.
        """
        return cls(board=Board.from_fen(fen))

    def to_fen(self) -> str:
        """Return the FEN representation of the current board state.

        Returns:
            str: FEN string describing the game's board.
        """
        return self.board.to_fen()

    def __post_init__(self) -> None:
        """Seed the repetition table with the initial board hash if available."""
        # Seed repetition with current position
        h = getattr(self.board, "zobrist_hash", None)
        if h is not None:
            self.repetition[h] = self.repetition.get(h, 0) + 1

    def legal_moves(self) -> List[Move]:
        """Return a list of currently legal moves for the side to move.

        Returns:
            List[Move]: Legal moves generated by the board.
        """
        return self.board.generate_legal_moves()

    def apply_move(self, move: Move) -> None:
        """Validate and apply a move, updating repetition data.

        Args:
            move (Move): Move to apply to the current position.

        Raises:
            ValueError: If ``move`` is not legal in the current position.
        """
        # Validate legality
        legal = self.board.generate_legal_moves()
        if not any(
            (m.from_sq == move.from_sq and m.to_sq == move.to_sq and m.promotion == move.promotion)
            for m in legal
        ):
            raise ValueError("illegal move")
        # Make move in-place and record for undo
        self.board.make_move(move)
        self.move_stack.append(move)
        # Update repetition with new hash
        h = self.board.zobrist_hash
        self.repetition[h] = self.repetition.get(h, 0) + 1

    def undo_move(self) -> None:
        """Undo the most recent move, restoring repetition counters.

        Raises:
            ValueError: If there is no move to undo.
        """
        if not self.move_stack:
            raise ValueError("no moves to undo")
        # Decrement count for current position
        curr = self.board.zobrist_hash
        if curr in self.repetition:
            self.repetition[curr] -= 1
            if self.repetition[curr] <= 0:
                del self.repetition[curr]
        last = self.move_stack.pop()
        self.board.unmake_move(last)

    # --- State flags for protocol ---
    def in_check(self) -> bool:
        """Return whether the side to move is in check.

        Returns:
            bool: True if the active player is currently in check.
        """
        return self.board.in_check()

    def checkmate(self) -> bool:
        """Return whether the side to move is checkmated.

        Returns:
            bool: True if no legal moves are available and the side to move is
            in check.
        """
        return (not self.board.has_legal_moves()) and self.board.in_check()

    def stalemate(self) -> bool:
        """Return whether the position is stalemated.

        Returns:
            bool: True if there are no legal moves and the side to move is not
            in check.
        """
        return (not self.board.has_legal_moves()) and (not self.board.in_check())

    def is_draw(self) -> bool:
        """Return whether the position is drawn by rule.

        Returns:
            bool: True if the 50-move rule, stalemate, or threefold repetition
            applies.
        """
        # Draw by 50-move rule, stalemate, or threefold repetition
        if self.board.halfmove_clock >= 100:
            return True
        if self.stalemate():
            return True
        count = self.repetition.get(self.board.zobrist_hash, 0)
        return count >= 3

    def move_history_uci(self) -> List[str]:
        """Return the played move list encoded in UCI long algebraic notation.

        Returns:
            List[str]: Moves encoded as UCI strings.
        """
        return [m.to_uci() for m in self.move_stack]
